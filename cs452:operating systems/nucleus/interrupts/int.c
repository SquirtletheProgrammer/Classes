/*
THIS CODE IS MY OWN WORK, IT WAS WRITTEN WITHOUT CONSULTING CODE
WRITTEN BY OTHER STUDENTS.
Dillon Wu 
*/
#include <string.h>
#include "../../h/const.h"
#include "../../h/types.h"
#include "../../h/vpop.h"
#include "../../h/util.h"
#include "../../h/procq.e"
#include "../../h/asl.e"
#include "../../h/main.e"
#include "../../h/trap.e"
#include "../../h/syscall.e"

#define TIMESLICE 5000L   // 500 milliseconds or are these microseconds?
#define PSEUDOC 100000L 

extern void save_time();

void static intterminalhandler();
void static intprinterhandler();
void static intdiskhandler();
void static intfloppyhandler();
void static intclockhandler();

state_t* oldterm;
state_t* oldprint;
state_t* olddisk;
state_t* oldflop;
state_t* oldclock;
int devnums[15] = {0}; // semaphore list for the devices
devreg_t* devregs[15]; // dev_reg struct for the devices
int pclock, counter, bug; // global pseudoclock
unsigned saved_stat[15]={0};
signed saved_len[15]={0};

void intinit()
{
	// interrupt init was already done in trap section
	// now introducing interrupt vector locations
	oldterm = (state_t*)(0x9c8);
	state_t* newterm = (state_t*)0x9c8 + 1;
	STST(oldterm);
	STST(newterm);
	newterm->s_sp = top_of_stack;
	newterm->s_pc = (int)intterminalhandler;
//	newterm->s_sr.ps_int = 7;

	oldprint = (state_t*)(0xa60);
	state_t* newprint = (state_t*)0xa60 + 1;
	STST(oldprint);
	STST(newprint);
	newprint->s_sp = top_of_stack;
	newprint->s_pc = (int)intprinterhandler;

	olddisk = (state_t*)(0xaf8);
	state_t* newdisk = (state_t*)0xaf8 + 1;
	STST(olddisk);
	STST(newdisk);
	newdisk->s_sp = top_of_stack;
	newdisk->s_pc = (int)intdiskhandler;
	
	oldflop = (state_t*)(0xb90);
	state_t* newflop = (state_t*)0xb90 + 1;
	STST(oldflop);
	STST(newflop);
	newflop->s_sp = top_of_stack;
	newflop->s_pc = (int)intfloppyhandler;

	oldclock = (state_t*)(0xc28);
	state_t* newclock = (state_t*)0xc28 + 1;
	STST(oldclock);
	STST(newclock);
	newclock->s_sp = top_of_stack;
	newclock->s_pc = (int)intclockhandler;
	// Allocating the device registers
	int i;
	for (i = 0; i <=14; i++) {
		devregs[i] = (devreg_t*)0x1400 + i;
	}
	counter = PSEUDOC / TIMESLICE;
		
}

// loads 0x2000 into status register which enables interrupts and sets supervisor mode, then the CPU halts until an interrupt occurs
void static sleep() {
	asm("stop	#0x2000");

}

// This is similar to semop but takes arguments instead
void static intsemop(int* sem, int op) {
	int to_run = 0;
	int old_sem = *sem;
	int new_sem = old_sem + op;
	if (op == -1) {
		if (new_sem < 0) {
			proc_t* head = headQueue(RQ);
			head->p_s = *sysarea;
			proc_t* rem = removeProc(&RQ);
			if (rem != (proc_t*)ENULL) {
				insertBlocked(sem, head);
				*sem+=op;
			}
			to_run = 1;
		}	
	} else if (op == 1 && old_sem <0) { 
		//if (new_sem >= 0) {
		proc_t* removed = removeBlocked(sem);
		if (removed!= (proc_t*)ENULL && removed->qcount == 0) {
			insertProc(&RQ, removed);
		//	}
		}
		*sem+=op;
	}
	if (to_run==1) {
		//proc_t* head = headQueue(RQ);
		//removeProc(&RQ);
		schedule();
	}

}

void waitforpclock(old){
	proc_t* head = headQueue(RQ);
	head->p_s = *sysarea;
	intsemop(&pclock, LOCK);
}


// performs P(block/-1) on semaphore that nucleus maintains in I/O device whose number is on D4
// appropriate device smaphore is V(unblock/1) every time an interrupt is generated by io device
// once process resumes after occurrence of interrupt for printer and terminal, 
// D2 contains contents of length register for appropriate device
// D3 contains contents of device's Status register
void waitforio() {
	// save the time
	if (RQ.next!= (proc_t*) ENULL) {
		proc_t* head = headQueue(RQ);
		save_time(head);
	}
	int dn = sysarea->s_r[4];
	// if an interrupt has occurred
	if (devnums[dn] != 0) {
		devnums[dn]--;
		sysarea->s_r[2] = saved_len[dn];
		sysarea->s_r[3] = saved_stat[dn];

	} else {
	// if an interrupt has not occurred
		if (RQ.next!=(proc_t*) ENULL) {
			intsemop(&devnums[dn], LOCK);
		}
	}
}

// loads timeslice into Interval Timer
void intschedule() {
	long t_interval = TIMESLICE;
	LDIT(&t_interval);
}

// function that prints within the nucleus
void intprint(char* message) {
	
	devreg_t *printer = devregs[5];

	printer->d_amnt = strlen(message);
	printer->d_badd = message;
	printer->d_op = IOWRITE;	
	sysarea->s_r[4] = PRINT0;
	waitforio();
}

void intdeadlock() {	
	// if there are processes blocked on pseudoclock / pclock semaphore
	int i, ioblock;
	ioblock = 0;
	for (i = 0; i < 15; i++) {
		if (devnums[i] != 0) {
			ioblock = 1;
			break;
		}
	}
	if (headBlocked(&pclock) != (proc_t*)ENULL) {
		intschedule();
		sleep();
	// if there are processes blocked on the I/O semaphore	
	} else if (ioblock == 1) { 
		sleep();
	// if no processes left
	} else if (headASL() == 0) {
		/* asm("trap #4"); */
		intprint("normal termination");
		HALT();
	} else {
		intprint("deadlock");
		HALT();
	}
}

// saves the completion status if a wait_for_io call has not been received
// or does an intsemop (UNLOCK) on semaphore corresponding to device
void static inthandler(int type, int val) {
	// device number, adder
	int dn, adder;
	adder = 0;
	state_t* to_load;
	if (type == 0) {
		// terminal
		adder = 0;
		to_load = oldterm;
	} else if (type == 1) {
		// printer
		adder = 5;
		to_load = oldprint;
	} else if (type == 2) {
		// disk
		adder = 7;
		to_load = olddisk;
	} else if (type == 3) {
		adder = 11;
		to_load = oldflop;
	}
	dn = val + adder;
	// if waitforiocall was not received, save completion status
	int empty = 0;
	if (RQ.next!= (proc_t*)ENULL) {
		proc_t* head = headQueue(RQ);
		save_time(head);
		empty = 1;
	}
	// devnums[dn] != -1
	if (devnums[dn] == 0) {
		// saving completion status
		devnums[dn]++;
		saved_len[dn] = devregs[dn]->d_dadd;
		saved_stat[dn] = devregs[dn]->d_stat;
		
	} else {
	// if waitforiocall was recieved
		proc_t* head = headBlocked(&devnums[dn]);
		intsemop(&devnums[dn], UNLOCK);
		head->p_s.s_r[2] = devregs[dn]->d_dadd;
		head->p_s.s_r[3] = devregs[dn]->d_stat;
		//to_load->s_r[2] = devregs[dn]->d_dadd;
		//to_load->s_r[3] = devregs[dn]->d_stat;
	}
	if (empty == 0) {
		schedule();
	} else {
		timer(to_load);
		LDST(to_load);
	}
}

void static intterminalhandler() {
	inthandler(TERMINAL, oldterm->s_tmp.tmp_int.in_dno);
}

void static intprinterhandler() {
	inthandler(PRINTER, oldprint->s_tmp.tmp_int.in_dno);
}

void static intdiskhandler() {
	inthandler(DISK, olddisk->s_tmp.tmp_int.in_dno);
}

void static intfloppyhandler() {
	inthandler(FLOPPY, oldflop->s_tmp.tmp_int.in_dno);
}

void static intclockhandler() {	
	if (RQ.next != (proc_t*)ENULL) {
		proc_t* head = removeProc(&RQ);
		save_time(head);
		head->p_s = *oldclock;
		insertProc(&RQ, head);
	}
	// unlock on pseudoclock semaphore if necessary
	// if there is something blocked on the pseudoclock semaphore
	counter--;
	if (pclock < 0 && counter <= 0 ) {
		intsemop(&pclock, UNLOCK);
		counter = PSEUDOC / TIMESLICE;
	}
	schedule();
}

